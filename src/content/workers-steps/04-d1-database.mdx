---
title: "D1 Database Integration"
description: "Learn to use Cloudflare D1 for relational data storage. Build a REST API with SQL database operations and understand serverless SQL."
stepNumber: 4
duration: "40 min"
difficulty: "intermediate"
tags: ["database", "d1", "sql", "relational", "api"]
prerequisites: ["Completed Step 3", "KV storage understanding", "Basic SQL knowledge"]
learningObjectives: [
  "Create and configure Cloudflare D1 databases",
  "Implement CRUD operations with SQL queries",
  "Build REST API endpoints with database integration",
  "Handle database transactions and error management"
]
---

import Alert from '../../components/Alert.astro';
import Callout from '../../components/Callout.astro';
import StepObjective from '../../components/StepObjective.astro';
import StepNavigation from '../../components/StepNavigation.astro';

<Callout type="globe" title="Cloudflare D1 Database">
D1 is Cloudflare's native serverless SQL database built on SQLite. It provides familiar SQL operations with global distribution and automatic scaling.

- **Serverless SQL:** Full SQL database without server management
- **Global Distribution:** Data replicated across Cloudflare's network
- **SQLite Compatible:** Use familiar SQL syntax and operations
- **Worker Integration:** Direct binding to your Workers for low-latency access
</Callout>

## Step 1: Create Your First D1 Database

<StepObjective 
  what="A D1 database configured and connected to your Worker for storing relational data."
  why="D1 provides structured data storage with SQL queries, perfect for complex data relationships and transactions."
/>

### üìù Create the Database

1. **Create a new D1 database:**
   ```bash
   npx wrangler d1 create my-blog-db
   ```

2. **Copy the configuration output and add to your `wrangler.jsonc`:**
   ```json
   {
     "name": "d1-worker",
     "main": "src/index.ts",
     "compatibility_date": "2024-01-01",
     "d1_databases": [
       {
         "binding": "DB",
         "database_name": "my-blog-db",
         "database_id": "your-database-id-here"
       }
     ]
   }
   ```

## Step 2: Initialize Database Schema

<StepObjective 
  what="A database schema with tables for a simple blog application with posts and comments."
  why="Proper schema design is crucial for relational databases and demonstrates SQL DDL operations."
/>

### üìù Create Schema File

Create a `schema.sql` file in your project root:

```sql
-- Drop tables if they exist (for development)
DROP TABLE IF EXISTS comments;
DROP TABLE IF EXISTS posts;

-- Create posts table
CREATE TABLE posts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  author TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Create comments table
CREATE TABLE comments (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  post_id INTEGER NOT NULL,
  author TEXT NOT NULL,
  content TEXT NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY (post_id) REFERENCES posts (id) ON DELETE CASCADE
);

-- Insert sample data
INSERT INTO posts (title, content, author) VALUES
  ('Getting Started with D1', 'D1 is Cloudflare''s serverless SQL database...', 'CloudflareTeam'),
  ('Building with Workers', 'Workers provide serverless compute at the edge...', 'DevRel'),
  ('SQL at the Edge', 'Running SQL queries globally distributed...', 'Engineering');

INSERT INTO comments (post_id, author, content) VALUES
  (1, 'Developer1', 'Great introduction to D1!'),
  (1, 'Developer2', 'Looking forward to trying this out.'),
  (2, 'Developer3', 'Workers are amazing for edge computing.');
```

### üìù Apply Schema

```bash
# Apply schema to local development database
npx wrangler d1 execute my-blog-db --local --file=./schema.sql

# Apply schema to production database
npx wrangler d1 execute my-blog-db --file=./schema.sql
```

## Step 3: Build REST API with D1

<StepObjective 
  what="A complete REST API for blog posts and comments using D1 database operations."
  why="Demonstrates real-world database integration patterns with proper error handling and SQL best practices."
/>

### üìù Create Your Worker

Update your `src/index.ts`:

```typescript
interface Post {
  id: number;
  title: string;
  content: string;
  author: string;
  created_at: string;
  updated_at: string;
}

interface Comment {
  id: number;
  post_id: number;
  author: string;
  content: string;
  created_at: string;
}

interface CreatePostRequest {
  title: string;
  content: string;
  author: string;
}

interface CreateCommentRequest {
  author: string;
  content: string;
}

export interface Env {
  DB: D1Database;
}

type CorsHeaders = Record<string, string>;

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const url = new URL(request.url);
    const { pathname } = url;
    
    // CORS headers for browser requests
    const corsHeaders: CorsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    };

    // Handle CORS preflight requests
    if (request.method === 'OPTIONS') {
      return new Response(null, { headers: corsHeaders });
    }

    try {
      // Route handling
      if (pathname === '/posts' && request.method === 'GET') {
        return await getPosts(env.DB, corsHeaders);
      }
      
      if (pathname === '/posts' && request.method === 'POST') {
        return await createPost(request, env.DB, corsHeaders);
      }
      
      if (pathname.startsWith('/posts/') && request.method === 'GET') {
        const postId = pathname.split('/')[2];
        return await getPost(postId, env.DB, corsHeaders);
      }
      
      if (pathname.startsWith('/posts/') && pathname.endsWith('/comments') && request.method === 'GET') {
        const postId = pathname.split('/')[2];
        return await getComments(postId, env.DB, corsHeaders);
      }
      
      if (pathname.startsWith('/posts/') && pathname.endsWith('/comments') && request.method === 'POST') {
        const postId = pathname.split('/')[2];
        return await createComment(request, postId, env.DB, corsHeaders);
      }

      return new Response('Not Found', { status: 404, headers: corsHeaders });
    } catch (error: any) {
      console.error('Error:', error);
      return new Response('Internal Server Error', { 
        status: 500, 
        headers: corsHeaders 
      });
    }
  },
};

// Get all posts
async function getPosts(db: D1Database, corsHeaders: CorsHeaders): Promise<Response> {
  const { results } = await db.prepare(`
    SELECT id, title, content, author, created_at, updated_at 
    FROM posts 
    ORDER BY created_at DESC
  `).all();
  
  return new Response(JSON.stringify(results), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}

// Create a new post
async function createPost(request: Request, db: D1Database, corsHeaders: CorsHeaders): Promise<Response> {
  const { title, content, author }: CreatePostRequest = await request.json();
  
  if (!title || !content || !author) {
    return new Response('Missing required fields', { 
      status: 400, 
      headers: corsHeaders 
    });
  }

  const { results } = await db.prepare(`
    INSERT INTO posts (title, content, author) 
    VALUES (?, ?, ?) 
    RETURNING id, title, content, author, created_at, updated_at
  `).bind(title, content, author).all();
  
  return new Response(JSON.stringify(results[0]), {
    status: 201,
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}

// Get a specific post
async function getPost(postId: string, db: D1Database, corsHeaders: CorsHeaders): Promise<Response> {
  const { results } = await db.prepare(`
    SELECT id, title, content, author, created_at, updated_at 
    FROM posts 
    WHERE id = ?
  `).bind(postId).all();
  
  if (results.length === 0) {
    return new Response('Post not found', { status: 404, headers: corsHeaders });
  }
  
  return new Response(JSON.stringify(results[0]), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}

// Get comments for a post
async function getComments(postId: string, db: D1Database, corsHeaders: CorsHeaders): Promise<Response> {
  const { results } = await db.prepare(`
    SELECT id, author, content, created_at 
    FROM comments 
    WHERE post_id = ? 
    ORDER BY created_at ASC
  `).bind(postId).all();
  
  return new Response(JSON.stringify(results), {
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}

// Create a comment
async function createComment(request: Request, postId: string, db: D1Database, corsHeaders: CorsHeaders): Promise<Response> {
  const { author, content }: CreateCommentRequest = await request.json();
  
  if (!author || !content) {
    return new Response('Missing required fields', { 
      status: 400, 
      headers: corsHeaders 
    });
  }

  // Check if post exists
  const { results: postCheck } = await db.prepare(`
    SELECT id FROM posts WHERE id = ?
  `).bind(postId).all();
  
  if (postCheck.length === 0) {
    return new Response('Post not found', { status: 404, headers: corsHeaders });
  }

  const { results } = await db.prepare(`
    INSERT INTO comments (post_id, author, content) 
    VALUES (?, ?, ?) 
    RETURNING id, author, content, created_at
  `).bind(postId, author, content).all();
  
  return new Response(JSON.stringify(results[0]), {
    status: 201,
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}
```

## Step 4: Test Your D1 API

<StepObjective 
  what="A fully functional blog API with posts and comments that you can test locally and deploy globally."
  why="Testing ensures your database operations work correctly and demonstrates the complete development workflow."
/>

### üìù Local Development

1. **Start local development:**
   ```bash
   npx wrangler dev --local
   ```

2. **Test the API endpoints:**

   ```bash
   # Get all posts
   curl http://localhost:8787/posts

   # Create a new post
   curl -X POST http://localhost:8787/posts \
     -H "Content-Type: application/json" \
     -d '{"title":"My New Post","content":"This is the content","author":"YourName"}'

   # Get a specific post
   curl http://localhost:8787/posts/1

   # Get comments for a post
   curl http://localhost:8787/posts/1/comments

   # Create a comment
   curl -X POST http://localhost:8787/posts/1/comments \
     -H "Content-Type: application/json" \
     -d '{"author":"Commenter","content":"Great post!"}'
   ```

### üìù Deploy to Production

```bash
npx wrangler deploy
```

<Alert type="success">
**üéâ Congratulations!** You've built a complete REST API with D1 database integration. Your API supports full CRUD operations for posts and comments with proper error handling and CORS support.
</Alert>

## Key Takeaways

- **D1 Integration:** Seamless SQL database binding to Workers
- **SQL Operations:** Prepared statements prevent SQL injection
- **Error Handling:** Proper validation and error responses
- **REST API Design:** Clean endpoint structure and HTTP methods
- **Global Distribution:** Your database runs at the edge worldwide

‚úÖ **Excellent work!** You've successfully integrated D1 database with your Workers. Ready to add AI capabilities in Step 5!

<StepNavigation 
  currentStep={4}
  totalSteps={7}
  prevStep={{
    title: "Workers KV Storage",
    slug: "#step-3"
  }}
  nextStep={{
    title: "Workers AI Integration",
    slug: "#step-5"
  }}
/>
